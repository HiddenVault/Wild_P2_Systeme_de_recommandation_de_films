Nom du script : preparation.name.basics.csv.py
Contenu du script :
import moduleOS
import moduleCSV
import moduleDownload
import moduleOS
import moduleDataframe
import modulePreparationHTML
import time
import pandas as pd

# Dictionnaire avec les noms des fichiers, leurs emplacements, leur type de séparateur et le nombre de lignes
files_dict = {
#    'title.akas.tsv': ('C:\Temp\Dataframes', '\t', 1000, 10, 11, 12),
#    'complementaire_tmdb_full.csv': ('C:\Temp/Dataframes', ',', 1000, 13, 14, 15),
#    'title.ratings.tsv': ('C:\Temp/Dataframes', '\t', 500, 16, 17, 18),
#    'title.principals.tsv': ('C:\Temp/Dataframes', '\t', 800, 19, 20, 21),
#    'title.episode.tsv': ('C:\Temp/Dataframes', '\t', 300, 22, 23, 24),
#    'title.crew.tsv': ('C:\Temp/Dataframes', '\t', 700, 25, 26, 27),
#    'title.basics.tsv': ('C:\Temp/Dataframes', '\t', 1200, 28, 29, 30),
    'name.basics.tsv': ('C:\Temp/Dataframes', '\t', -1, 31, 32, 33)
}

# Préfixe pour les fichiers HTML et CSV
file_prefix = 'P_'

# Début du chronomètre
import time
start_time = time.time()

# Parcours du dictionnaire de fichiers
for file_name, (path, separator, nrows_value, first_rows, sample_rows, last_rows) in files_dict.items():
    content = moduleDownload.download_or_read_file(file_name, path, separator, nrows_value)
    
    # Utilisez la fonction pour créer le répertoire des fichiers .csv
    csv_directory = './data/preparation'
    moduleOS.create_csv_directory(csv_directory)
    
    if content is not None:
        df_original = moduleDataframe.create_dataframe(content, separator, nrows_value)  
        if df_original is not None:
            df_copy = df_original.copy()

            # Suppression des colonnes 'birthYear' et 'deathYear'
            columns_to_drop = ['birthYear', 'deathYear']
            df_copy = df_original.drop(columns=columns_to_drop)

            # Création des colonnes de valeurs dummies pour 'primaryProfession'
            dummies = df_copy['primaryProfession'].str.get_dummies(sep=',')
            df_copy = pd.concat([df_copy, dummies], axis=1)

            # Renommage de la colonne 'knownForTitles' en 'tconst'
            df_copy = df_copy.rename(columns={'knownForTitles': 'tconst'})
            # Division de la colonne 'tconst' en listes de valeurs
            df_copy['tconst'] = df_copy['tconst'].str.split(',')
            df_copy = df_copy.explode('tconst')

            # Supprimer la colonne 'primaryProfession'
            columns_to_drop = ['primaryProfession']
            df_copy = df_copy.drop(columns=columns_to_drop)

            # Réinitialiser les index si nécessaire
            # df_copy.reset_index(drop=True, inplace=True)    

            # Créez les noms des fichiers avec le préfixe
            csv_file_name = f'{file_prefix}{file_name}.csv'
            html_file_name = f'{file_prefix}{file_name}.html'
            html_file_name_with_prefix = html_file_name

            moduleCSV.create_csv_files(df_copy, csv_directory, csv_file_name, first_rows, sample_rows, last_rows, nrows_value) # Fonction pour créer des fichiers CSV
            local_file_path = f'./data/preparation/{html_file_name}'  # Déclaration de local_file_path
            modulePreparationHTML.create_html_file(df_copy, html_file_name, nrows_value, start_time, files_dict, local_file_path, file_prefix='P_') # Fonction pour créer un fichier HTML à partir du DataFrame

            # Fonction pour obtenir les informations du DataFrame
            moduleDataframe.get_dataframe_info(df_copy)

            # Fonction pour télécharger un fichier depuis une URL ou lire depuis un chemin local
            moduleDownload.download_or_read_file(file_name, path, separator, nrows_value)

            # Fonction pour créer un DataFrame à partir du contenu du fichier
            moduleDataframe.create_dataframe(content, separator, nrows_value)





Nom du script : modulePreparationHTML.py
Contenu du script :
import moduleDataframe
import time

# Fonction pour créer un fichier HTML à partir du DataFrame
def create_html_file(df, file_name, nrows_value, start_time, files_dict, local_file_path, file_prefix=''):
    import psutil
    import os
    import moduleFTP
    info_output = moduleDataframe.get_dataframe_info(df)

    if info_output is not None:
        info_output = info_output.replace('\n', '<br>')
    else:
        info_output = "Aucune information disponible"

    # Enlever le préfixe du nom du fichier
    # print("Before: file_name =", file_name)
    # print("file_prefix =", file_prefix)
    file_name = file_name.replace(file_prefix, '').replace('.html', '')
    # print("After: file_name =", file_name)

    # Chemin absolu du répertoire du script Python
    script_directory = os.path.dirname(os.path.abspath(__file__))

    # Chemin absolu du fichier CSS en utilisant le répertoire du script
    css_file_path = os.path.join(script_directory, "style.css")

    # Lecture du contenu du fichier CSS
    css_content = ""
    with open(css_file_path, 'r') as css_file:
        css_content = css_file.read()

    first_rows = files_dict[file_name][3]  # x premières lignes
    sample_rows = files_dict[file_name][4]  # x lignes au hasard
    last_rows = files_dict[file_name][5]  # x dernières lignes

    # Ajout du style CSS directement dans le fichier HTML
    html_content = f"""
    <html>
    <head>
        <meta charset="UTF-8">
        <title>{file_name}</title>
        <style>
        {css_content}  # Intégrer le contenu CSS lu depuis le fichier
        </style>
    </head>
    <body>
        <h2>{file_name}</h2>
        <p>L'analyse porte sur les <b>{nrows_value}</b> premières lignes du dataframe</p>
        <!-- Informations sur les ressources -->
        <div>
            <h3>Informations sur les ressources :</h3>
            <p>Temps de génération : {round(time.time() - start_time)} secondes</p>
            <p>Utilisation CPU : {psutil.cpu_percent(interval=None, percpu=True)} %</p>
            <p>Utilisation mémoire : {round((psutil.virtual_memory().used) / (1024 * 1024))} Go</p>
            <p>Processeur : {psutil.cpu_freq().current} MHz</p>
        </div>  
        <!-- Informations sur le dataframe -->
        <div>
            <h3>Informations sur le DataFrame ( df.info() ):</h3> 
            <table>
                {info_output}
            </table>
        </div>  
        <div>            
            <h3>Noms des colonnes ( df.columns ) :</h3> 
            <table>
                <tr><td>{', '.join(df.columns)}</td></tr>
            </table>
        </div>  
        <div>            
            <h3>Types de données des colonnes ( df.dtypes ):</h3> 
            <table>
                {df.dtypes.to_frame().to_html(classes='table table-bordered', header=False)}
            </table>
        </div>  
        <div>            
            <h3>Statistiques descriptives pour les colonnes numériques ( df.describe() ):</h3> 
            <table>
                {df.describe().to_html(classes='table table-bordered', header=False)}
            </table>
        </div>  
        <div>            
            <h3>Valeurs manquantes dans le Dataframe ( df.isnull().sum() ) :</h3>
            <table>
                {df.isnull().sum().to_frame().to_html(classes='table table-bordered', header=False)}
            </table>
        </div>  
        <div>
            <h3>{first_rows} premières lignes :</h3>
            <table> 
                {df.head(first_rows).to_html(index=False, escape=False, classes='table table-bordered')}
            </table>
            <h3>{sample_rows} lignes au hasard :</h3>
            <table> 
                {df.sample(sample_rows).to_html(index=False, escape=False, classes='table table-bordered')}
            </table>
            <h3>{last_rows} dernières lignes :</h3>
            <table> 
                {df.tail(last_rows).to_html(index=False, escape=False, classes='table table-bordered')}
            </table>
        </div>
    </body>
    </html>
    """

    # Écriture du contenu HTML dans le fichier
    with open(local_file_path, 'w', encoding='UTF-8') as f:
        f.write(html_content)
    
    print(f"Exporté en HTML : {local_file_path}")

Nom du script : moduleDataframe.py
Contenu du script :
import sys
import pandas as pd
from io import StringIO

def get_dataframe_info(df):
    original_stdout = sys.stdout
    sys.stdout = StringIO()
    df.info()
    info_output = sys.stdout.getvalue()
    sys.stdout = original_stdout
    if info_output.strip() == '':
        return "Aucune information disponible"
    return info_output

def create_dataframe(content, separator, nrows_value):
    try:
        df = pd.read_csv(StringIO(content), sep=separator, nrows=nrows_value, low_memory=False, encoding='UTF-8')
        return df
    except pd.errors.ParserError as e:
        print(f"Erreur lors de la lecture du fichier: {e}")
        return None


